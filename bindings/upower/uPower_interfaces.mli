(* File auto-generated by obus_gen_interface.best, DO NOT EDIT. *)
open OBus_member
module Org_freedesktop_UPower : sig
  val m_EnumerateDevices : (unit, OBus_path.t list) Method.t
  val s_DeviceAdded : string Signal.t
  val s_DeviceRemoved : string Signal.t
  val s_DeviceChanged : string Signal.t
  val s_Changed : unit Signal.t
  val s_Sleeping : unit Signal.t
  val s_Resuming : unit Signal.t
  val m_AboutToSleep : (unit, unit) Method.t
  val m_Suspend : (unit, unit) Method.t
  val m_SuspendAllowed : (unit, bool) Method.t
  val m_Hibernate : (unit, unit) Method.t
  val m_HibernateAllowed : (unit, bool) Method.t
  val p_DaemonVersion : (string, [ `readable ]) Property.t
  val p_CanSuspend : (bool, [ `readable ]) Property.t
  val p_CanHibernate : (bool, [ `readable ]) Property.t
  val p_OnBattery : (bool, [ `readable ]) Property.t
  val p_OnLowBattery : (bool, [ `readable ]) Property.t
  val p_LidIsClosed : (bool, [ `readable ]) Property.t
  val p_LidIsPresent : (bool, [ `readable ]) Property.t
  val make :
    ?notify_mode : 'a OBus_object.notify_mode ->
    m_EnumerateDevices : (OBus_path.t list OBus_context.t -> 'a -> unit -> OBus_path.t list Lwt.t) ->
    m_AboutToSleep : (unit OBus_context.t -> 'a -> unit -> unit Lwt.t) ->
    m_Suspend : (unit OBus_context.t -> 'a -> unit -> unit Lwt.t) ->
    m_SuspendAllowed : (bool OBus_context.t -> 'a -> unit -> bool Lwt.t) ->
    m_Hibernate : (unit OBus_context.t -> 'a -> unit -> unit Lwt.t) ->
    m_HibernateAllowed : (bool OBus_context.t -> 'a -> unit -> bool Lwt.t) ->
    p_DaemonVersion : ('a -> string React.signal) ->
    p_CanSuspend : ('a -> bool React.signal) ->
    p_CanHibernate : ('a -> bool React.signal) ->
    p_OnBattery : ('a -> bool React.signal) ->
    p_OnLowBattery : ('a -> bool React.signal) ->
    p_LidIsClosed : ('a -> bool React.signal) ->
    p_LidIsPresent : ('a -> bool React.signal) ->
    unit -> 'a OBus_object.interface
end
module Org_freedesktop_UPower_Device : sig
  val m_Refresh : (unit, unit) Method.t
  val s_Changed : unit Signal.t
  val m_GetHistory : (string * int32 * int32, (int32 * float * int32) list) Method.t
  val m_GetStatistics : (string, (float * float) list) Method.t
  val p_NativePath : (string, [ `readable ]) Property.t
  val p_Vendor : (string, [ `readable ]) Property.t
  val p_Model : (string, [ `readable ]) Property.t
  val p_Serial : (string, [ `readable ]) Property.t
  val p_UpdateTime : (int64, [ `readable ]) Property.t
  val p_Type : (int32, [ `readable ]) Property.t
  val p_PowerSupply : (bool, [ `readable ]) Property.t
  val p_HasHistory : (bool, [ `readable ]) Property.t
  val p_HasStatistics : (bool, [ `readable ]) Property.t
  val p_Online : (bool, [ `readable ]) Property.t
  val p_Energy : (float, [ `readable ]) Property.t
  val p_EnergyEmpty : (float, [ `readable ]) Property.t
  val p_EnergyFull : (float, [ `readable ]) Property.t
  val p_EnergyFullDesign : (float, [ `readable ]) Property.t
  val p_EnergyRate : (float, [ `readable ]) Property.t
  val p_Voltage : (float, [ `readable ]) Property.t
  val p_TimeToEmpty : (int64, [ `readable ]) Property.t
  val p_TimeToFull : (int64, [ `readable ]) Property.t
  val p_Percentage : (float, [ `readable ]) Property.t
  val p_IsPresent : (bool, [ `readable ]) Property.t
  val p_State : (int32, [ `readable ]) Property.t
  val p_IsRechargeable : (bool, [ `readable ]) Property.t
  val p_Capacity : (float, [ `readable ]) Property.t
  val p_Technology : (int32, [ `readable ]) Property.t
  val p_RecallNotice : (bool, [ `readable ]) Property.t
  val p_RecallVendor : (string, [ `readable ]) Property.t
  val p_RecallUrl : (string, [ `readable ]) Property.t
  val make :
    ?notify_mode : 'a OBus_object.notify_mode ->
    m_Refresh : (unit OBus_context.t -> 'a -> unit -> unit Lwt.t) ->
    m_GetHistory : ((int32 * float * int32) list OBus_context.t -> 'a -> string * int32 * int32 -> (int32 * float * int32) list Lwt.t) ->
    m_GetStatistics : ((float * float) list OBus_context.t -> 'a -> string -> (float * float) list Lwt.t) ->
    p_NativePath : ('a -> string React.signal) ->
    p_Vendor : ('a -> string React.signal) ->
    p_Model : ('a -> string React.signal) ->
    p_Serial : ('a -> string React.signal) ->
    p_UpdateTime : ('a -> int64 React.signal) ->
    p_Type : ('a -> int32 React.signal) ->
    p_PowerSupply : ('a -> bool React.signal) ->
    p_HasHistory : ('a -> bool React.signal) ->
    p_HasStatistics : ('a -> bool React.signal) ->
    p_Online : ('a -> bool React.signal) ->
    p_Energy : ('a -> float React.signal) ->
    p_EnergyEmpty : ('a -> float React.signal) ->
    p_EnergyFull : ('a -> float React.signal) ->
    p_EnergyFullDesign : ('a -> float React.signal) ->
    p_EnergyRate : ('a -> float React.signal) ->
    p_Voltage : ('a -> float React.signal) ->
    p_TimeToEmpty : ('a -> int64 React.signal) ->
    p_TimeToFull : ('a -> int64 React.signal) ->
    p_Percentage : ('a -> float React.signal) ->
    p_IsPresent : ('a -> bool React.signal) ->
    p_State : ('a -> int32 React.signal) ->
    p_IsRechargeable : ('a -> bool React.signal) ->
    p_Capacity : ('a -> float React.signal) ->
    p_Technology : ('a -> int32 React.signal) ->
    p_RecallNotice : ('a -> bool React.signal) ->
    p_RecallVendor : ('a -> string React.signal) ->
    p_RecallUrl : ('a -> string React.signal) ->
    unit -> 'a OBus_object.interface
end
module Org_freedesktop_UPower_QoS : sig
  val m_SetMinimumLatency : (string * int32, unit) Method.t
  val m_RequestLatency : (string * int32 * bool, int32) Method.t
  val m_CancelRequest : (string * int32, unit) Method.t
  val m_GetLatency : (string, int32) Method.t
  val s_LatencyChanged : (string * int32) Signal.t
  val m_GetLatencyRequests : (unit, (int32 * int32 * int32 * string * int64 * bool * string * string * int32) list) Method.t
  val s_RequestsChanged : unit Signal.t
  val make :
    ?notify_mode : 'a OBus_object.notify_mode ->
    m_SetMinimumLatency : (unit OBus_context.t -> 'a -> string * int32 -> unit Lwt.t) ->
    m_RequestLatency : (int32 OBus_context.t -> 'a -> string * int32 * bool -> int32 Lwt.t) ->
    m_CancelRequest : (unit OBus_context.t -> 'a -> string * int32 -> unit Lwt.t) ->
    m_GetLatency : (int32 OBus_context.t -> 'a -> string -> int32 Lwt.t) ->
    m_GetLatencyRequests : ((int32 * int32 * int32 * string * int64 * bool * string * string * int32) list OBus_context.t -> 'a -> unit -> (int32 * int32 * int32 * string * int64 * bool * string * string * int32) list Lwt.t) ->
    unit -> 'a OBus_object.interface
end
module Org_freedesktop_UPower_Wakeups : sig
  val p_HasCapability : (bool, [ `readable ]) Property.t
  val m_GetTotal : (unit, int32) Method.t
  val s_TotalChanged : int32 Signal.t
  val m_GetData : (unit, (bool * int32 * float * string * string) list) Method.t
  val s_DataChanged : unit Signal.t
  val make :
    ?notify_mode : 'a OBus_object.notify_mode ->
    p_HasCapability : ('a -> bool React.signal) ->
    m_GetTotal : (int32 OBus_context.t -> 'a -> unit -> int32 Lwt.t) ->
    m_GetData : ((bool * int32 * float * string * string) list OBus_context.t -> 'a -> unit -> (bool * int32 * float * string * string) list Lwt.t) ->
    unit -> 'a OBus_object.interface
end
