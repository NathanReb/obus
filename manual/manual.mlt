(*
 * manual.mlt
 * ----------
 * Copyright : (c) 2010, Jeremie Dimino <jeremie@dimino.org>
 * Licence   : BSD3
 *
 * This file is a part of obus, an ocaml implementation of D-Bus.
 *)

open Latex

let obus = texttt "OBus"
let dbus = texttt "D-Bus"
let abstract body = command \"abstract\" [(T, body)] T

let lowlevel_section = label ()
let name_tracking = label ()

let use_colors = Array.length Sys.argv > 1 && Sys.argv.(1) = \"-use-colors\"

let caml_styles, obus_styles, shell_styles =
  if use_colors then
    (Colorize.Caml.default_styles, Colorize.OBus.default_styles, Colorize.Shell.default_styles)
  else
    (Colorize.Caml.bw_styles, Colorize.OBus.bw_styles, Colorize.Shell.bw_styles)

let caml_code name =
  Colorize.Caml.input_file ~styles:caml_styles (\"../codes/\" ^ name ^ \".ml\")

let obus_code name =
  Colorize.OBus.input_file ~styles:obus_styles (\"../codes/\" ^ name ^ \".obus\")

let shell_code name =
  Colorize.Shell.input_file ~styles:shell_styles (\"../codes/\" ^ name ^ \".sh\")

let doc = "
{abstract "

  {dbus} is an inter-processes communication protocol, or IPC for
  short, which has recently become a standard on desktop oriented
  computers. It is now possible to talk to a lot application using
  {dbus}. Moreover, it has many bindings/implementations for differents
  languages, which make it easily accessible. {obus} is a pure OCaml
  implementation of this protocol. What makes it different from other
  bindings/implementations is that it is the only one using
  cooperative threads, which make it very simple to fully exploit the
  asynchronous nature of D-Bus.

  {textbf "Note:"} it is advised to have some knowledge about the
  {texttt "Lwt"} library before reading this manual.

"}

{tableofcontents}

(*****************************************************************************)
{section "Introduction"}

{subsection "Overview of {obus}"}

{subsubsection "Packages"}

  The main packages of the {obus} distribution is the {texttt "obus"} package,
  available via findlib. It contains the core library. Moveover, {obus} although
  provides packages for using a bunch of services of the Freedesktop project:

  {itemize
     [texttt "obus.hal";
      texttt "obus.notification";
      texttt "obus.network-manager";
      texttt "obus.policykit";
      texttt "obus.udisks";
      texttt "obus.upower"]}

  The use of these packages is straightforward and you need to know almost nothing
  about {dbus} or {obus}. For example, here is a program which open a popup notification:

  {caml_code \"notification\"}

  Lastly {obus} also provides a syntax extension (package {texttt "obus.syntax"})
  and a parser/printer for the IDL language (package {texttt "obus.idl"}).

{subsubsection "Modules"}

  {obus} contains about 30 public modules. But do not be scared, most of the
  time you will need a very small subset of them. These modules can be
  divided in two categories:

  {itemize ["the high-level API"; "the low-level API"]}

  The low-level API is described in the section {ref_ lowlevel_section} of this
  manual. Note that you must have a good knowledge of {dbus} to use it.

(*****************************************************************************)
{section "Basis"}

  In this section we will describe the minimum you must know to use {obus} and
  interfaces for {dbus} services written with {obus} (like the ones provided
  in the {obus} distribution: {texttt "obus.notification"},
  {texttt "obus.upower"}, {dots}).

{subsection "Connections and message buses"}

  A {emph "connection"} is a way of exchanging messages with
  another application speaking the {dbus} protocol. Most of the time
  applications use connection to a special application called a
  {emph "message bus"}. A message bus act as a router between several
  applications. On a desktop computer, there are two well-known instances:
  the {emph "system"} message bus, and the user {emph "session"} message bus.

  The first one is unique given a computer, and use security
  policies. The second is unique given a user session. Its goal is to
  allow programs running in the session to talk to each other. {obus}
  offers two function for connecting to these message buses:
  {texttt "OBus_bus.session"} and {texttt "OBus_bus.system"}.

  The session bus exists for the life-time of a user session. It exits
  when the session is closed, and any programs using it should exit to, that is
  why {obus} will exit the program when the connection to the session bus is
  lost. However this behavior can be changed.

  On the other hand the system bus can be restarted and program using it may
  try to reopen the connection. System-wide application should handle the lost
  of the connection with the system bus.

  Here is a small example which connects the session bus and prints its id:

  {caml_code \"bus_id\"}

{subsection "Names"}

  On a message bus, applications are referenced using names. There is a special
  category of names called {emph "unique names"}. Each time an application connects
  to a bus, the bus give it a unique name. Unique name are of the form {texttt ":1.42"}
  and cannot be changed. You can think of a unique name as an {emph "ip"} (such as
  {texttt "192.168.1.42"}).

  Once connected, the unique name can is returned by the function {texttt "OBus_bus.name"}.
  Here is an example of a program that prints its unique name:

  {caml_code \"unique_name\"}

  Unique name are usefull to uniquelly identify an application. However when you want
  to use a specific service you may prefer using a well-known name such as
  {texttt "org.freedesktop.Notifications"}. {dbus} allows applications to own
  as many non-unique names as they want. You can think of a non-unique name as
  a {emph "dns"} (such as \"obus.forge.ocamlcore.org\").

  Names can be requested or resolved using functions of the {texttt "OBus_bus"} module.

  Here is an example:

  {caml_code \"names\"}

  Note that the {texttt "OBus_resolver"} module offer a better way of resolving names
  and monitoring name owners. See section {ref_ name_tracking} for details.

{subsection "Peers"}

  A {emph "peer"} represent an application accessible through a {dbus} connection.
  To uniquelly identify a peer one needs a connection and a name. The module
  {texttt "OBus_peer"} defines the type type of peers. There are two requests
  that should be available on all peers: {texttt "ping"} and {texttt "get_machine_id"}.
  The first one just ping the peer to see if it is alive, and the second returns the id of
  the machine the peer is currently running on.

{subsection "Objects and proxies"}

  In order to export services, {dbus} uses the concept of {emph "objects"}. An application
  may holds as many objects as it wants. From the inside of the application, {dbus} objects are
  generally mapped to language native objects. From the outside, objects are refered by
  {emph "object-pathes"}, which looks like \"{texttt "/org/freedesktop/DBus"}\". You can
  think of an object path as a pointer.

  Objects may have members which are organized by interfaces (such as \"{texttt "org.freedesktop.DBus"}\").
  There are three types of members:

  {itemize ["Methods"; "Signals"; "Properties"]}

  Methods act like functions. Clients can call methods of objects. Signals are spontaneous
  events that may occurs at any time. Clients may register to these signals and then be notified
  when a signal arrive. Properties act as variable, that can be read and/or written and sometimes
  monitored.

  In order to uniquelly identify an object, we need its path and the peer that owns it. We call such
  a thing a {emph "proxy"}. Proxies are defined in the module {texttt "OBus_proxy"}.

  Here is a simple example on how to call a method on a proxy
  (we will explain latter what means the {texttt "C.seq..."} things):

  {caml_code \"proxy\"}

(*****************************************************************************)
{section "Interaction between the OCaml world and the D-Bus world"}

{subsection "Value mapping"}

  {dbus} defines its own type system, which is used to serialize and deserialize
  messages. These types are defined in the module {texttt "OBus_value.T"} and {dbus}
  values that are defined in the module {texttt "OBus_value.V"}. When a message is
  received, its contents is represented as a value of type {texttt "OBus_value.V.sequence"}.
  Simillary, when a message is sent, it is first converted into this format.

  Manipulating boxed {dbus} values is not very handy. To make the interaction more
  transparent, {obus} defines a set of type combinators which allow to easilly switch
  between the {dbus} representation and the ocaml representation. These convertors
  are defined in the module {texttt "OBus_value.C"}.

  Here is an example of convertion (in the toplevel):

  {caml_code \"values\"}

{subsection "Errors mapping"}

  A call to a method may fails. In this case the service sends an error to the caller.
  {dbus} errors are mapped to ocaml exceptions by the {texttt "OBus_error"} module.
  Basically, to defines a mapping between an exception and a {dbus} error, here is what
  you have to do:

  {caml_code \"errors\"}

  Or, if you use the syntax extension:

  {caml_code \"errors_syntax\"}

(*****************************************************************************)
{section "Using D-Bus services"}

  In this section we describe the canonical way of using a {dbus} service with {obus}.

{subsection "Defining and using members"}

  For all types of members (methods, signals and properties), {dbus} provides types
  to defines them and functions to use these definitions. A member definition contains
  all the information about a member. For example, here is the definition of a method call
  named \"foo\" on interface \"org.foo.bar\" which takes a string and returns an 32-bits signed
  integer:

  {caml_code \"method\"}

  Once a member is defined, it can be used by the corresponding modules:

  {caml_code \"members\"}

  Of course, writting definitions by hand may be very boring and error-prone. To avoid that
  {obus} can automatically convert introspection data into ocaml definitions.

{subsection "Using tools to generate member definitions"}

  There are two tools that are usefull for client-side code: {texttt "obus-gen-interface"} and
  {texttt "obus-gen-client"}. The first one converts an xml introspection document (or an idl file)
  into an ocaml module containing all the camlized definitions. This generated file is in fact also
  needed for server-side code. Note that fiels produced by {texttt "obus-gen-interface"} are not meant
  to be edited.

  The second tool maps members into their ocaml counterpart: methods are mapped to functions, signals to
  value of type {texttt "OBus_signal.t"} and properties to values of type {texttt "OBus_property.t"}.
  This generated file is meant to be edited. For example, you can edit it in order to change the type of values
  taken/returned by methods.

{subsection "The {obus} IDL language"}

  Since editing XML is horrible, {obus} provides a intermediate language to write
  {dbus} interfaces. Moreover this language allow you to automatically converts
  integers to ocaml variants when needed.

  The syntax is pretty simple. Here is an example, taken from {obus} sources (file {texttt "src/oBus_interfaces.obus"}):

  {obus_code \"intf\"}

  All {obus} tools that accept XML files also accept IDL files. Moreover it is possible
  to convert them by using {texttt "obus-idl2xml"} and {texttt "obus-xml2idl"}.

{subsection ~label:name_tracking "Name tracking"}

  The owner of a on-unique name may change over the time. {obus} provides the {texttt "OBus_resolver"}
  module to deals with it. The owner is mapped into a React's signal holding the current owner
  of a name.

(*****************************************************************************)
{section "Writing D-Bus services"}

  In this section we describe the canonical way of writing {dbus} services with {obus}.

  Local {dbus} objects are represented by values of type {texttt "OBus_object.t"}. The main
  operations on objects are: adding an interface and exporting it on a connection.
  Exporting an object means making it available to all peers reachable from the connection.

  In order to add callable methods to objects you have to create interfaces descriptions
  (of type {texttt "'a OBus_object.interface"}) and add them to objects.

  The canonical way to create interfaces with {obus} is to first write its signature in
  an XML introspection file or in an {obus} idl file, then convert it into an ocaml
  definition module with {texttt "obus-gen-interface"} and in a template ocaml source file
  with {texttt "obus-gen-server"}.

  Here is a small example of interface:

  {obus_code \"intf_server\"}

  It is converted with:

  {shell_code \"intf_gen\"}

  Now all that you have to do is to edit the file generated by {texttt "obus-gen-server"}
  and replace the \"Not implemented\" errors by your code.

  Once it is done, here is how to actually create the object, add the interface
  and export it:

  {caml_code \"export\"}

  Note the you can attach custom data to the object with {texttt "OBus_object.attach"}.

(*****************************************************************************)
{section "One-to-one communication"}

  Instead of connection to a message bus, you may want to directly connects to
  another application. This can be done with {texttt "OBus_connection.of_addresses"}.

  If you want to allow other applications to connect to your application then
  you have to start a server. Starting a server is very simple, all you have
  to do is to call {texttt "OBus_server.make"} with a callback that will receive
  new connections.

(*****************************************************************************)
{section ~label:lowlevel_section "Low-level use of D-Bus"}

{subsection "Message filters"}

{subsection "Matching rules"}

{subsection "Defining new transports"}

{subsection "Defining new authentication mechanisms"}

"

let set_mono_font name =
  command
    ~packages:[(\"xltxtra\", \"\")]
    ~opt:(A, "Mapping=tex-text,Scale=0.8")
    \"setmonofont\"
    [(A, name)]
    A

let () =
  Melt.emit
    ~file:(if use_colors then \"manual-colored.tex\" else \"manual.tex\")
    (document
       ~options:[`A4paper]
       ~title:"OBus user manual"
       ~author:"Jérémie Dimino"
       ~prelude:(set_mono_font "DejaVu Sans Mono")
       ~packages:[("fullpage", "")]
       doc)
