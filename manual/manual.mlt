(*
 * manual.mlt
 * ----------
 * Copyright : (c) 2010, Jeremie Dimino <jeremie@dimino.org>
 * Licence   : BSD3
 *
 * This file is a part of obus, an ocaml implementation of D-Bus.
 *)

open Latex

let obus = texttt "OBus"
let dbus = texttt "D-Bus"
let abstract body = command \"abstract\" [(T, body)] T

let lowlevel_section = label ()
let name_tracking = label ()

let use_colors = Array.length Sys.argv > 1 && Sys.argv.(1) = \"-use-colors\"

let styles =
  if use_colors then
    Caml_code.default_styles
  else
    Caml_code.bw_styles

let caml_code name =
  Caml_code.input_file ~styles (\"../codes/\" ^ name ^ \".ml\")

let doc = "
{abstract "

  {dbus} is an inter-processes communication protocol, or IPC for
  short, which has recently become a standard on desktop oriented
  computers. It is now possible to talk to a lot application using
  {dbus}. Moreover, it has many bindings/implementations for differents
  languages, which make it easily accessible. {obus} is a pure OCaml
  implementation of this protocol. What makes it different from other
  bindings/implementations is that it is the only one using
  cooperative threads, which make it very simple to fully exploit the
  asynchronous nature of D-Bus.

  {textbf "Note:"} it is advised to have some knowledge about the
  {texttt "Lwt"} library before reading this manual.

"}

{tableofcontents}

(*****************************************************************************)
{section "Introduction"}

{subsection "Overview of {obus}"}

{subsubsection "Packages"}

  The main packages of the {obus} distribution is the {texttt "obus"} package,
  available via findlib. It contains the core library. Moveover, {obus} although
  provides packages for using a bunch of services of the Freedesktop project:

  {itemize
     [texttt "obus.hal";
      texttt "obus.notification";
      texttt "obus.network-manager";
      texttt "obus.policykit";
      texttt "obus.udisks";
      texttt "obus.upower"]}

  The use of these packages is straightforward and you need to know almost nothing
  about {dbus} or {obus}. For example, here is a program which open a popup notification:

  {caml_code \"notification\"}

  Lastly {obus} also provides a syntax extension (package {texttt "obus.syntax"})
  and a parser/printer for the IDL language (package {texttt "obus.idl"}).

{subsubsection "Modules"}

  {obus} contains about 30 public modules. But do not be scared, most of the
  time you will need a very small subset of them. These modules can be
  divided in two categories:

  {itemize ["the high-level API"; "the low-level API"]}

  The low-level API is described in the section {ref_ lowlevel_section} of this
  manual. Note that you must have a good knowledge of {dbus} to use it.

(*****************************************************************************)
{section "Basis"}

  In this section we will describe the minimum you must know to use {obus} and
  interfaces for {dbus} services written with {obus} (like the ones provided
  in the {obus} distribution: {texttt "obus.notification"},
  {texttt "obus.upower"}, {dots}).

{subsection "Connections and message buses"}

  A {emph "connection"} is a way of exchanging messages with
  another application speaking the {dbus} protocol. Most of the time
  applications use connection to a special application called a
  {emph "message bus"}. A message bus act as a router between several
  applications. On a desktop computer, there are two well-known instances:
  the {emph "system"} message bus, and the user {emph "session"} message bus.

  The first one is unique given a computer, and use security
  policies. The second is unique given a user session. Its goal is to
  allow programs running in the session to talk to each other. {obus}
  offers two function for connecting to these message buses:
  {texttt "OBus_bus.session"} and {texttt "OBus_bus.system"}.

  The session bus exists for the life-time of a user session. It exits
  when the session is closed, and any programs using it should exit to, that is
  why {obus} will exit the program when the connection to the session bus is
  lost. However this behavior can be changed.

  On the other hand the system bus can be restarted and program using it may
  try to reopen the connection. System-wide application should handle the lost
  of the connection with the system bus.

  Here is a small example which connects the session bus and prints its id:

  {caml_code \"bus_id\"}

{subsection "Names"}

  On a message bus, applications are referenced using names. There is a special
  category of names called {emph "unique names"}. Each time an application connects
  to a bus, the bus give it a unique name. Unique name are of the form {texttt ":1.42"}
  and cannot be changed. You can think of a unique name as an {emph "ip"} (such as
  {texttt "192.168.1.42"}).

  Once connected, the unique name can is returned by the function {texttt "OBus_bus.name"}.
  Here is an example of a program that prints its unique name:

  {caml_code \"unique_name\"}

  Unique name are usefull to uniquelly identify an application. However when you want
  to use a specific service you may prefer using a well-known name such as
  {texttt "org.freedesktop.Notifications"}. {dbus} allows applications to own
  as many non-unique names as they want. You can think of a non-unique name as
  a {emph "dns"} (such as \"obus.forge.ocamlcore.org\").

  Names can be requested or resolved using functions of the {texttt "OBus_bus"} module.

  Here is an example:

  {caml_code \"names\"}

  Note that the {texttt "OBus_resolver"} module offer a better way of resolving names
  and monitoring name owners. See section {ref_ name_tracking} for details.

{subsection "Peers"}

  A {emph "peer"} represent an application accessible through a {dbus} connection.
  To uniquelly identify a peer one needs a connection and a name. The module
  {texttt "OBus_peer"} defines the type type of peers. There are two requests
  that should be available on all peers: {texttt "ping"} and {texttt "get_machine_id"}.
  The first one just ping the peer to see if it is alive, and the second returns the id of
  the machine the peer is currently running on.

{subsection "Objects and proxies"}

  In order to export services, {dbus} uses the concept of {emph "objects"}. An application
  may holds as many objects as it wants. From the inside of an application {dbus} objects are
  generally mapped to the native notion of objects. From the outside, objects are refered by
  {emph "object-pathes"}, which looks like \"{texttt "/org/freedesktop/DBus"}\".

  Objects may have members which are organized by interfaces (such as \"{texttt "org.freedesktop.DBus"}\").
  There are three types of members:

  {itemize ["Methods"; "Signals"; "Properties"]}

  Methods act like functions. Clients can call methods of objects. Signals are spontaneous
  events that may occurs at any time. Clients may register to these signals and then be notified
  when a signal arrive. Proeprties act as variable, that can be read and/org written and sometimes
  monitored.

  The next sections explains how to use these members with {obus}.

{subsection "Methods, signals and properties"}

{subsection "Errors mapping"}

(*****************************************************************************)
{section "Using D-Bus services"}

{subsection "Defining members"}

{subsection "Using members"}

{subsection "Using tools to generate member definitions"}

{subsection "The {obus} IDL language"}

{subsection ~label:name_tracking "Name tracking"}

(*****************************************************************************)
{section "Writing D-Bus services"}

{subsection "Defining interfaces"}

{subsection "Objects management"}

(*****************************************************************************)
{section "One-to-one communication"}

{subsection "Starting a  server"}

(*****************************************************************************)
{section ~label:lowlevel_section "Low-level use of D-Bus"}

{subsection "Message filters"}

{subsection "Matching rules"}

{subsection "Defining new transports"}

{subsection "Defining new authentication mechanisms"}

"

let set_mono_font name =
  command
    ~packages:[(\"xltxtra\", \"\")]
    ~opt:(A, "Mapping=tex-text,Scale=0.8")
    \"setmonofont\"
    [(A, name)]
    A

let () =
  Melt.emit
    ~file:(if use_colors then \"manual-colored.tex\" else \"manual.tex\")
    (document
       ~options:[`A4paper]
       ~title:"OBus user manual"
       ~author:"Jérémie Dimino"
       ~prelude:(set_mono_font "DejaVu Sans Mono")
       ~packages:[("fullpage", "")]
       doc)
