(*
 * wire.mli
 * --------
 * Copyright : (c) 2008, Jeremie Dimino <jeremie@dimino.org>
 * Licence   : BSD3
 *
 * This file is a part of obus, an ocaml implemtation of dbus.
 *)

(** Used by autogenerated interfaces *)

type ptr = int
    (** A position in a buffer *)

type buffer = string
    (** A buffer containing a marshaled value *)

type byte_order = Little_endian | Big_endian
    (** Message byte order *)

(** {6 Errors} *)

exception Out_of_bounds
  (** Exception raised when the end of the buffer is reached. We do
      not that exception instead of the one traditionally raised by
      string functions [Invalid_argument "out of bounds"] to make a
      difference between out of bounds of serialization functions and
      ones of convertions functions. *)

exception Content_error of string
  (** This exception must be raised by convertion functions a value is
      invalid. *)

exception Convertion_failed of string * exn
  (** Exception raised while reading/writing if one of the convertion
      function fail. Contain the original exception and its string
      representation. *)

exception Reading_error of string
  (** Exception raised if a dbus marshaled message is invalid. In this
      case the connection will be closed. *)

exception Writing_error of string
  (** Exception which can be raised if a message cannot be
      written. Possible reason are that an array exceed the maximum
      size, or the message is too big *)

(** {6 Basics writing/reading functions which depends on byte
    order} *)

(** The names of functions for reading/writing are of the form
    action-caml-type_dbus-type *)

type 'a writer = buffer -> ptr -> 'a -> ptr

module type Writer = sig
  val byte_order : byte_order
  val write_int_int16 : int writer
  val write_int_int32 : int writer
  val write_int_int64 : int writer
  val write_int_uint16 : int writer
  val write_int_uint32 : int writer
  val write_int_uint64 : int writer
  val write_int32_int32 : int32 writer
  val write_int64_int64 : int64 writer
  val write_int32_uint32 : int32 writer
  val write_int64_uint64 : int64 writer
  val write_float_double : float writer
  val write_bool_boolean : bool writer
  val write_string_string : string writer
  val write_string_object_path : string writer
    (** There is two cases for arrays: elements are padded on an 4 or
        less boundary, so there is nothing special to do since the
        length need a 4 boundary alignment. Or elements are padded on
        a 8 boundary so there is possibly 4 bytes of padding after the
        length (which are always present, even if the array is empty,
        and ignored in the array length).

        The first argument is a function which write all the element
        of the array *)
  val write_array : 'a writer -> 'a writer
  val write_array8 : 'a writer -> 'a writer
end

type 'a reader = buffer -> ptr -> ptr * 'a

module type Reader = sig
  val byte_order : byte_order
  val read_int_int16 : int reader
  val read_int_int32 : int reader
  val read_int_int64 : int reader
  val read_int_uint16 : int reader
  val read_int_uint32 : int reader
  val read_int_uint64 : int reader
  val read_int32_int32 : int32 reader
  val read_int64_int64 : int64 reader
  val read_int32_uint32 : int32 reader
  val read_int64_uint64 : int64 reader
  val read_float_double : float reader
  val read_bool_boolean : bool reader
  val read_string_string : string reader
  val read_string_object_path : string reader
  val read_array : (ptr -> buffer -> ptr -> 'a) -> 'a reader
  val read_array8 : (ptr -> buffer -> ptr -> 'a) -> 'a reader
    (** The first argument of these two function is a function which
        take as first argument a limit. *)
end

module LEWriter : Writer
module BEWriter : Writer
module LEReader : Reader
module BEReader : Reader

(** {6 Other functions which does not depends on byte order} *)

val write_char_byte : char writer
val write_int_byte : int writer
val write_string_signature : string writer

val read_char_byte : char reader
val read_int_byte : int reader
val read_string_signature : string reader

val check_signature : buffer -> ptr -> string -> unit
  (** [check_signature buffer ptr sig] compare the marshaled signature
      at pos [ptr] in [buffer] with [sig]. If it match do nothing,
      if not raise an [Content_error]. *)

val read_until : (ptr -> 'a -> (ptr -> 'a -> 'a) -> 'a) -> 'a -> ptr -> ptr -> 'a
  (** [read_until reader acc ptr limit] read values with [reader]
      until it reach [limit]. [reader] take a pointer, an accumulator
      and a continuation. *)

val read_until_rev : (ptr -> (ptr -> 'a) -> 'a) -> 'a -> ptr -> ptr -> 'a
  (** [read_until_rev reader acc ptr limit] Used to read arrays and
      add element in reverse order. *)

(** {6 Padding} *)

(** Note: paddings function assumes that the length of the buffer is a
    multiple of 8 *)

val wpad2 : buffer -> ptr -> ptr
val wpad4 : buffer -> ptr -> ptr
val wpad8 : buffer -> ptr -> ptr
val rpad2 : ptr -> ptr
val rpad4 : ptr -> ptr
val rpad8 : ptr -> ptr
