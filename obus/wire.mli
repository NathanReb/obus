(*
 * wire.mli
 * --------
 * Copyright : (c) 2008, Jeremie Dimino <jeremie@dimino.org>
 * Licence   : BSD3
 *
 * This file is a part of obus, an ocaml implemtation of dbus.
 *)

(** Used by autogenerated interfaces *)

type ptr = int
    (** A position in a buffer *)

type buffer = string
    (** A buffer containing a marshaled value *)

exception Content_error of string
  (** This exception must be raised by convertion functions if a value
      is invalid *)

(** Exceptions that can be raised by auto-generated
    marshaling/unmarshaling functions *)

module Reading : sig

  (** Consistency errors, the message is an invalid dbus message *)

  exception Array_too_big
    (** The marshaled representation of an array is bigger than
        allowed by the dbus specification *)
  exception Invalid_array_size
    (** The anounced size of an array does not match is real size *)
  exception Invalid_message_size
    (** The anounced size of the message is incorrent *)

  (** Content errors *)

  exception Invalid_signature
    (** The signature for a variant does not correspond to what we
        expect *)
end

module Writing : sig
  exception Array_too_big
    (** The marhaled representation of an array is too big to be
        sent *)
end

external native_byte_order : unit -> int = "caml_native_byte_order"

module LEWriter : sig
  type 'a t = buffer -> ptr -> 'a -> unit
  external int_int16 : int t = "caml_writer_le_int_int16"
  external int_int32 : int t = "caml_writer_le_int_int32"
  external int_int64 : int t = "caml_writer_le_int_int64"
  external int_uint16 : int t = "caml_writer_le_int_uint16"
  external int_uint32 : int t = "caml_writer_le_int_uint32"
  external int_uint64 : int t = "caml_writer_le_int_uint64"
  external int32_int32 : int32 t = "caml_writer_le_int32_int32"
  external int64_int64 : int64 t = "caml_writer_le_int64_int64"
  external int32_uint32 : int32 t = "caml_writer_le_int32_uint32"
  external int64_uint64 : int64 t = "caml_writer_le_int64_uint64"
  external float_double : float t = "caml_writer_le_float_double"
end

module BEWriter : sig
  type 'a t = buffer -> ptr -> 'a -> unit
  external int_int16 : int t = "caml_writer_be_int_int16"
  external int_int32 : int t = "caml_writer_be_int_int32"
  external int_int64 : int t = "caml_writer_be_int_int64"
  external int_uint16 : int t = "caml_writer_be_int_uint16"
  external int_uint32 : int t = "caml_writer_be_int_uint32"
  external int_uint64 : int t = "caml_writer_be_int_uint64"
  external int32_int32 : int32 t = "caml_writer_be_int32_int32"
  external int64_int64 : int64 t = "caml_writer_be_int64_int64"
  external int32_uint32 : int32 t = "caml_writer_be_int32_uint32"
  external int64_uint64 : int64 t = "caml_writer_be_int64_uint64"
  external float_double : float t = "caml_writer_be_float_double"
end

external pad2 : buffer -> ptr -> ptr = "caml_pad2"
external pad4 : buffer -> ptr -> ptr = "caml_pad4"
external pad8 : buffer -> ptr -> ptr = "caml_pad8"

external zero2 : buffer -> ptr -> unit = "caml_zero2"
external zero3 : buffer -> ptr -> unit = "caml_zero3"
external zero4 : buffer -> ptr -> unit = "caml_zero4"
external zero5 : buffer -> ptr -> unit = "caml_zero5"
external zero6 : buffer -> ptr -> unit = "caml_zero6"
external zero7 : buffer -> ptr -> unit = "caml_zero7"

module LEReader = sig
  type 'a t = buffer -> ptr -> 'a
  external int_int16 : int t = "caml_reader_le_int_int16"
  external int_int32 : int t = "caml_reader_le_int_int32"
  external int_int64 : int t = "caml_reader_le_int_int64"
  external int_uint16 : int t = "caml_reader_le_int_uint16"
  external int_uint32 : int t = "caml_reader_le_int_uint32"
  external int_uint64 : int t = "caml_reader_le_int_uint64"
  external int32_int32 : int32 t = "caml_reader_le_int32_int32"
  external int64_int64 : int64 t = "caml_reader_le_int64_int64"
  external int32_uint32 : int32 t = "caml_reader_le_int32_uint32"
  external int64_uint64 : int64 t = "caml_reader_le_int64_uint64"
  external float_double : float t = "caml_reader_le_float_double"
end

module BEReader : sig
  type 'a t = buffer -> ptr -> 'a
  external int_int16 : int t = "caml_reader_be_int_int16"
  external int_int32 : int t = "caml_reader_be_int_int32"
  external int_int64 : int t = "caml_reader_be_int_int64"
  external int_uint16 : int t = "caml_reader_be_int_uint16"
  external int_uint32 : int t = "caml_reader_be_int_uint32"
  external int_uint64 : int t = "caml_reader_be_int_uint64"
  external int32_int32 : int32 t = "caml_reader_be_int32_int32"
  external int64_int64 : int64 t = "caml_reader_be_int64_int64"
  external int32_uint32 : int32 t = "caml_reader_be_int32_uint32"
  external int64_uint64 : int64 t = "caml_reader_be_int64_uint64"
  external float_double : float t = "caml_reader_be_float_double"
end

external string_match : buffer -> ptr -> string -> int -> bool = "caml_match_string"

val realloc_buffer : string -> int -> string
  (** [realloc buffer n] return a new buffer bigger than [buffer] with
      same first [n] bytes *)
