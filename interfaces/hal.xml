<node>
  <interface name="org.freedesktop.Hal.Manager" cname="Manager">
    <interf>
      val proxy : Bus.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus = Bus.make_proxy bus interface "org.freedesktop.Hal" "/org/freedesktop/Hal/Manager"
    </implem>
    <method name="GetAllDevices">
      <arg name="devices" direction="out" type="ao"/>
    </method>
    <method name="GetAllDevicesWithProperties">
      <arg name="devices_with_props" direction="out" type="a(oa{sv})"/>
    </method>
    <method name="DeviceExists">
      <arg name="does_it_exist" direction="out" type="b"/>
      <arg name="udi" direction="in" type="o"/>
    </method>
    <method name="FindDeviceStringMatch">
      <arg name="devices" direction="out" type="ao"/>
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="s"/>
    </method>
    <method name="FindDeviceByCapability">
      <arg name="devices" direction="out" type="ao"/>
      <arg name="capability" direction="in" type="s"/>
    </method>
    <method name="NewDevice">
      <arg name="temporary_udi" direction="out" type="s"/>
    </method>
    <method name="Remove">
      <arg name="udi" direction="in" type="s"/>
    </method>
    <method name="CommitToGdl">
      <arg name="temporary_udi" direction="in" type="s"/>
      <arg name="global_udi" direction="in" type="s"/>
    </method>
    <method name="AcquireGlobalInterfaceLock">
      <arg name="interface_name" direction="in" type="s"/>
      <arg name="exclusive" direction="in" type="b"/>
    </method>
    <method name="ReleaseGlobalInterfaceLock">
      <arg name="interface_name" direction="in" type="s"/>
    </method>
    <method name="SingletonAddonIsReady">
      <arg name="command_line" direction="in" type="s"/>
    </method>
    <signal name="DeviceAdded">
      <arg name="udi" type="s"/>
    </signal>
    <signal name="DeviceRemoved">
      <arg name="udi" type="s"/>
    </signal>
    <signal name="NewCapability">
      <arg name="udi" type="s"/>
      <arg name="cap_name" type="s"/>
    </signal>
    <signal name="GlobalInterfaceLockAcquired">
      <arg name="interface_name" type="s"/>
      <arg name="lock_holder" type="s"/>
      <arg name="num_locks" type="i"/>
    </signal>
    <signal name="GlobalInterfaceLockReleased">
      <arg name="interface_name" type="s"/>
      <arg name="lock_holder" type="s"/>
      <arg name="num_locks" type="i"/>
    </signal>
  </interface>
  <interface name="org.freedesktop.Hal.Device" cname="Device">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="GetAllProperties">
      <arg name="properties" direction="out" type="a{sv}"/>
    </method>
    <method name="SetMultipleProperties">
      <arg name="properties" direction="in" type="a{sv}"/>
    </method>
    <method name="GetProperty">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="v"/>
    </method>
    <method name="GetPropertyString">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="s"/>
    </method>
    <method name="GetPropertyStringList">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="as"/>
    </method>
    <method name="GetPropertyInteger">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="i"/>
    </method>
    <method name="GetPropertyBoolean">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="b"/>
    </method>
    <method name="GetPropertyDouble">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="out" type="d"/>
    </method>
    <method name="SetProperty">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="v"/>
    </method>
    <method name="SetPropertyString">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="s"/>
    </method>
    <method name="SetPropertyStringList">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="as"/>
    </method>
    <method name="SetPropertyInteger">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="i"/>
    </method>
    <method name="SetPropertyBoolean">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="b"/>
    </method>
    <method name="SetPropertyDouble">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="d"/>
    </method>
    <method name="RemoveProperty">
      <arg name="key" direction="in" type="s"/>
    </method>
    <method name="GetPropertyType">
      <arg name="key" direction="in" type="s"/>
      <arg name="type" direction="out" type="i"/>
    </method>
    <method name="PropertyExists">
      <arg name="key" direction="in" type="s"/>
      <arg name="does_it_exist" direction="out" type="b"/>
    </method>
    <method name="AddCapability">
      <arg name="capability" direction="in" type="s"/>
    </method>
    <method name="QueryCapability">
      <arg name="capability" direction="in" type="s"/>
      <arg name="does_it_have_capability" direction="out" type="b"/>
    </method>
    <method name="Lock">
      <arg name="reason" direction="in" type="s"/>
      <arg name="acquired_lock" direction="out" type="b"/>
    </method>
    <method name="Unlock">
      <arg name="released_lock" direction="out" type="b"/>
    </method>
    <method name="AcquireInterfaceLock">
      <arg name="interface_name" direction="in" type="s"/>
      <arg name="exclusive" direction="in" type="b"/>
    </method>
    <method name="ReleaseInterfaceLock">
      <arg name="interface_name" direction="in" type="s"/>
    </method>
    <method name="IsCallerLockedOut">
      <arg name="interface_name" direction="in" type="s"/>
      <arg name="caller_sysbus_name" direction="in" type="s"/>
      <arg name="whether_caller_is_locked_out" direction="out" type="b"/>
    </method>
    <method name="IsCallerPrivileged">
      <arg name="action" direction="in" type="s"/>
      <arg name="action_parameters" type="as"/>
      <arg name="caller_sysbus_name" direction="in" type="s"/>
      <arg name="result" direction="out" type="s"/>
    </method>
    <method name="IsLockedByOthers">
      <arg name="interface_name" direction="in" type="s"/>
      <arg name="whether_it_is_locked_by_others" direction="out" type="b"/>
    </method>
    <method name="StringListAppend">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="s"/>
    </method>
    <method name="StringListPrepend">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="s"/>
    </method>
    <method name="StringListRemove">
      <arg name="key" direction="in" type="s"/>
      <arg name="value" direction="in" type="s"/>
    </method>
    <method name="EmitCondition">
      <arg name="condition_name" direction="in" type="s"/>
      <arg name="condition_details" direction="in" type="s"/>
      <arg name="rc" direction="out" type="b"/>
    </method>
    <method name="Rescan">
      <arg name="call_had_sideeffect" direction="out" type="b"/>
    </method>
    <method name="Reprobe">
      <arg name="call_had_sideeffect" direction="out" type="b"/>
    </method>
    <method name="ClaimInterface">
      <arg name="interface_name" direction="in" type="s"/>
      <arg name="introspection_xml" direction="in" type="s"/>
      <arg name="rc" direction="out" type="b"/>
    </method>
    <method name="AddonIsReady">
      <arg name="rc" direction="out" type="b"/>
    </method>
    <signal name="PropertyModified">
      <arg name="num_updates" type="i"/>
      <arg name="updates" type="a(sbb)"/>
    </signal>
    <signal name="Condition">
      <arg name="cond_name" type="s"/>
      <arg name="cond_details" type="s"/>
    </signal>
    <signal name="InterfaceLockAcquired">
      <arg name="interface_name" type="s"/>
      <arg name="lock_holder" type="s"/>
      <arg name="num_locks" type="i"/>
    </signal>
    <signal name="InterfaceLockReleased">
      <arg name="interface_name" type="s"/>
      <arg name="lock_holder" type="s"/>
      <arg name="num_locks" type="i"/>
    </signal>
  </interface>
  <interface name="org.freedesktop.Hal.Device.Volume" cname="Device.Volume">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="Mount">
      <arg name="mount_point" direction="in" type="s"/>
      <arg name="fstype" direction="in" type="s"/>
      <arg name="extra_options" direction="in" type="as"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="Unmount">
      <arg name="extra_options" direction="in" type="as"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="Eject">
      <arg name="extra_options" direction="in" type="as"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.Storage" cname="Device.Storage">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="Eject">
      <arg name="extra_options" direction="in" type="as"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="CloseTray">
      <arg name="extra_options" direction="in" type="as"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.Storage.Removable" cname="Device.Storage.Removable">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="CheckForMedia">
      <arg name="call_had_sideeffect" direction="out" type="b"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.WakeOnLan" cname="Device.WakeOnLan">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="GetSupported">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="GetEnabled">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="SetEnabled">
      <arg name="enable" direction="in" type="b"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.SystemPowerManagement" cname="Device.SystemPowerManagement">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="Suspend">
      <arg name="num_seconds_to_sleep" direction="in" type="i"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="SuspendHybrid">
      <arg name="num_seconds_to_sleep" direction="in" type="i"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="Hibernate">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="Shutdown">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="Reboot">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="SetPowerSave">
      <arg name="enable_power_save" direction="in" type="b"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.CPUFreq" cname="Device.CPUFreq">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="SetCPUFreqGovernor">
      <arg name="governor_string" direction="in" type="s"/>
    </method>
    <method name="SetCPUFreqPerformance">
      <arg name="value" direction="in" type="i"/>
    </method>
    <method name="SetCPUFreqConsiderNice">
      <arg name="value" direction="in" type="b"/>
    </method>
    <method name="GetCPUFreqGovernor">
      <arg name="return_code" direction="out" type="s"/>
    </method>
    <method name="GetCPUFreqPerformance">
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="GetCPUFreqConsiderNice">
      <arg name="return_code" direction="out" type="b"/>
    </method>
    <method name="GetCPUFreqAvailableGovernors">
      <arg name="return_code" direction="out" type="as"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.LaptopPanel" cname="Device.LaptopPanel">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="SetBrightness">
      <arg name="brightness_value" direction="in" type="i"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="GetBrightness">
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.DockStation" cname="Device.DockStation">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="Undock">
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
  <interface name="org.freedesktop.Hal.Device.KillSwitch" cname="Device.KillSwitch">
    <interf>
      val proxy : Bus.t -&gt; Path.t -&gt; t Proxy.t
    </interf>
    <implem>
      let proxy bus path = Bus.make_proxy bus interface "org.freedesktop.Hal" path
    </implem>
    <method name="SetPower">
      <arg name="power" direction="in" type="b"/>
      <arg name="return_code" direction="out" type="i"/>
    </method>
    <method name="GetPower">
      <arg name="return_code" direction="out" type="i"/>
    </method>
  </interface>
</node>
